* DDD（Domain-Driven Design ） 实践

：https://zhuanlan.zhihu.com/p/651873384

** 为什么需要DDD

1. 复杂系统设计：系统多，业务j罗ifuza，概念不清晰，有什么合适的方法帮助我们理清楚边界，逻辑和概念？
2. 多团队协同：边界不清晰系统依赖复杂，语言不同意导致沟通和理解困难。有没有一种方式把业务和技术概念统一，大家用一种语言沟通。
3. 设计与实现的一致性： PRD 详细设计和代码实现天差万别，有什么方法可以吧业务需求快速的转换为设计，同时还要保持设计与代码的一致性？
4. 架构统一，可复用资产和扩展性： 取决于开发同学具备很好的抽象能力和高变成的技能。有什么好的方法可以指导我们做抽象和实现。

** DDD 的价值

1. 边界清晰的设计方法： 通过领域划分，识别哪些需求应该在哪些领域，不断拉齐团队对需求的认知，分儿治之，控制规模。
2. 统一语言：团队在有边界的上下文中有意识的形成对事务进行统一的描述，形成统一的概念（模型）
3. 业务领域知识沉淀：通过反复论证和提炼模型，使得模型必须与业务的真实世界保持一致使模型可以很好的传递和维护。
4. 面向业务建模：领域模型与数据模型分离，业务复杂度和计数复杂度分离。


** DDD 架构

*** 分层架构

[[file:~/文档/StudyFile/Note/Image/v2-b13e840a60f6630daf63cc97d004f253_720w.png][DDD架构]]

1.用户接口层： 调用应用层完整具体的用户请求。包含 controller，远程调用服务等
2.应用层APP： 尽量简单，不包含业务规则，而只为下一层中的领域对象做协调任务，分配工作，重点对领域层做编排完成复杂业务场景。
包含AppService，消息处理等。
3.领域层Domain：负责表达业务概念和业务逻辑，领域层是系统的核心，包含：模型，值对，域服务，事件。
4.基础层：对所有上层提供基础能力：包括：数据库操作，发送消息，消费消息，缓存等。

调用关系，用户接口层->应用层->领域层->基础层

*** 六边形架构

[[file:~/文档/StudyFile/Note/Image/v2-d893a5d180d85a5bae10af33b26c9169_720w.png][六边形架构]]

六边形架构：通过适配器的方式与外部交互，将应用服务与领域服务封装在系统内部
分层胶固：依然是分层架构，它核心改变的是依赖关系
领域层依赖倒置：领域层依赖基础层 倒置成 基础层依赖领域层，这个简单的变化使得领域层不依赖任务层，其他层依赖领域层，使得领域层只表达业务逻辑且稳定。

** 领域模型

1.领域：业务范围，范围就是边界
2.子领域：领域可大可小，我们将一个领域进行拆解形成子领域，子领域还可以进行拆解。当一个领域太大的时候需要进行细化拆解。
3.模型：基于某个业务领域识别出这个业务领域的聚合，聚合根，界限上下文，实体，值对象。

*** 核心领域

决定产品和公司核心竞争的子域或者核心域，他是业务成功的主要因素和公司的核心竞争力。直接产生业务价值。

*** 通用域

没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。例如：权限，登录等等 间接对业务产生价值。

*** 支撑域

支撑其他领域业务，且具有企业特性，但不具有通用性。间接对业务产生价值。

*** 为什么要划分核心域、通用域和支撑域

为了对需求进行优先级的排序

** 界限上下文

业务边界的划分，这个边界可以是一个领域或者多个领域的集合。负责业务需要多个领域编排完成一个复杂的业务流程。界限上下文可以作为为服务划分方法。本质还是高内聚低耦合，只是界限上下文只是
站在更高的层面来进行划分。如何划分，我的方法是一个界限上下文必须支持一个完整的业务流程，保证这个业务流程。

** 实体

1.定义：实体有唯一的标识，有生命周期且具有延续性。例如一个交易订单，从创建订单我们会给他一个订单编号并且是唯一的这就是实体唯一标识。
同时订单实体会从创建，支付，发货等过程最终走到终态这就是实体的生命周期。订单实体在这个过程中属性发生了变化，但订单还是那个订单，不会因为属性的变化而变化，这就是实体的延续性。

2.实体的业务形态：实体能够反映业务的真实形态，实体是从用例提取出来的。领域模型中的实体是多个属性、操作或行为的载体。

3. 实体的代码形态：我们要保证实体代码形态与业务形态的一致性。那么实体的代码应该也有属性和行为，也就是我们说的充血模型，但实际情况下我们使用的是贫血模型。
贫血模型缺点是业务逻辑分散，更像数据库模型，充血模型能够反映业务，但过重依赖数据库操作，而且复杂场景下需要编排领域服务，会导致事务过长，影响性能。所以我们使用充血模型，
但行为里面只涉及业务逻辑的内存操作。

4. 实体的运行形态：实体有唯一ID 当我在流程中对实体属性进行修改，但ID 不会变，实体还是那个实体。
5. 实体的数据库形态： 实体在映射数据库模型时，一般是一对一，也有一对多的情况。

** 值对象

1.定义： 通过对象属性值来识别的对象，他将多个相关属性组合为一个整体概念。在DDD 中用来描述特定方面，并且十一个没有标识符的对象，叫做值对象。值对象没有唯一标识，没有声明周期，不可修改，
当值对象发生改变是只能替换。

2.值对象业务形态： 值对象是描述实体的特征，大多数情况一个实体有很多属性，一般都是平铺，这些数据进行匪类和聚合后能够表达一个业务含义，方便沟通而不关注细节。

3.值对象的代码形态： 实体的单一属性是值对象，例如：字符串，整型，枚举。多个属性的集合也是值对象，这个时候我们把这个集合设计为一个CLASS，但没有ID。例如商品实体下的航段就是一个值对象。
航段是描述商品的特征，航段不需要ID，可以直接整体替换。商品为什么是一个实体，而不是描述订单特征，因为需要表达谁买了什么商品，所以我们需要知道哪一个商品，因此需要ID来标识唯一性。

[[file:~/文档/StudyFile/Note/Image/v2-285cf47297a40873fe54dd78f8073600_r.png][值对象]]

4.值对象的运行形态：值对象创建后就不允许修改了，只能用另外一个值对象来整体替换。
当我们修改地址时，从页面传入一个新的地址对象替换调用person对象的地址即可。如果我们把address设计成实体，
必然存在ID，那么我们需要从页面传入的地址对象的ID与person里面的地址对像的ID进行比较，如果相同就更新，
如果不同先删除数据库在新增数据。


5.值对象的数据库形态：有两种方式嵌入式和序列化大对象。

案例1:以属性嵌入的方式形成的人员实体对象，地址值对象直接以属性值嵌入人员实体中。

当我们只有一个地址的时候使用嵌入式比较好，如果多个地址必须有序列化大对象，同时可以支持搜索。

案例2：以序列化大对象的方式形成的人员实体对象，地址值对象被序列化成大对象Json串后，嵌入人员实体中。

支持多个地址存储，不支持搜索。

** 值对象的优势和局限

1.简化数据库设计，提升数据库操作的性能（多表新增和修改，关联表查询）。
2.虽然简化数据库设计，但是领域模型还是可以表达业务。
3.序列化的方式会使搜索实现困难（通过搜索引擎可以解决）。

**  聚合和聚合根

1.多个实体和值对象组成的我们叫聚合，聚合的内部一定的高内聚。这个聚合里面一定有一个实体是聚合根。

2.聚合与领域的关系：聚合也是范围的划分，领域也是范围的划分。领域与聚合可以是一对一，也可以是一对多的关系。

3.聚合根的作用是保证内部的实体的一致性，对外只需要对聚合根进行操作。

** 限界上下文，域，聚合，实体，值对象的关系

1.领域包含限界上下文，限界上下文包含子域，子域包含聚合，聚合包含实体和值对象。


** 事件风暴

*** 参与者
除了领域专家，事件风暴的其他参与者可以是DDD专家、架构师、产品经理、项目经理、开发人员和测试人员等项目团队成员。

*** 事件风暴准备材料
一面墙和一支笔。

*** 事件风暴的关注点

在领域建模的过程中，我们需要重点关注这类业务的语言和行为。比如某些业务动作或行为（事件）是否会触发下一个业务动作，
这个动作（事件）的输入和输出是什么？是谁（实体）发出的什么动作（命令），触发了这个动作（事件）…我们可以从这些暗藏的词汇中，分析出领域模型中的事件、命令和实体等领域对象。

实体执行命令产生事件。

*** 业务场景的分析
通过业务场景和用例找出实体，命令，事件。

*** 领域建模

领域建模时，我们会根据场景分析过程中产生的领域对象，比如命令、事件等之间关系，找出产生命令的实体，分析实体之间的依赖关系组成聚合，为聚合划定限界上下文，
建立领域模型以及模型之间的依赖。领域模型利用限界上下文向上可以指导微服务设计，通过聚合向下可以指导聚合根、实体和值对象的设计。


** 如何建模


1.用例场景梳理：就是一句话需求，但我们需要把一些模糊的概念通过对话的方式逐步得到明确的需求，在加以提炼和抽象。
2.建模方法论：词法分析（找名词和动词），领域边界
3.模型验证

*** 协同单自动化分单案例

......... 看原文


*** DDD 规范

[[file:~/文档/StudyFile/Note/Image/v2-9df005cea9267811efc8dc6932056476_720w.png][DDD 目录规范]]

每一层都定义了相应的接口主要目的是规范代码：

1.application：CRQS模式，ApplicationCmdService是command，ApplicationQueryService是query
2.service：是领域服务规范，其中定义了DomainService，应用系统需要继承它。
3.model：是聚合根，实体，值对象的规范。
    （1）Aggregate和BaseAggregate：聚合根定义
    （2）Entity和BaseEntity：实体定义
    （3）Value和BaseValue：值对象定义
    （4）Param和BaseParam：领域层参数定义，用作域服务，聚合根和实体的方法参数
    （5）Lazy：描述聚合根属性是延迟加载属性，类似与hibernate。
    （6）Field：实体属性，用来实现update-tracing

```
/**
 * 实体属性，update-tracing
 * @param <T>
 */
public final class Field<T> implements Changeable {
    private boolean changed = false;
    private T value;
    private Field(T value){
        this.value = value;
    }
    public void setValue(T value){
        if(!equalsValue(value)){
            this.changed = true;
        }
        this.value = value;
    }
    @Override
    public boolean isChanged() {
        return changed;
    }
    public T getValue() {
        return value;
    }
    public boolean equalsValue(T value){
        if(this.value == null && value == null){
            return true;
        }
        if(this.value == null){
            return false;
        }
        if(value == null){
            return false;
        }
        return this.value.equals(value);
    }
    public static <T> Field<T> build(T value){
        return new Field<T>(value);
    }
}
```

4.repository
     （1）Repository：仓库定义
     （2） AggregateRepository：聚合根仓库,定义聚合根常用的存储和查询方法
5.event：事件处理
6.exception：定义了不同层用的异常
     （1）AggregateException：聚合根里面抛的异常
     （2）RepositoryException：基础层抛的异常
     （3）EventProcessException：事件处理抛的

