* dubbo

** dubbo 的请求流程

1. 启动时 provider 会把所有的接口注册到注册中心，并且订阅动态配置 configurators
2. 消费者 consumer 会去注册中心订阅自己需要的 providers configurations，routers
3. 订阅信息变成时，会推送订阅信息 providers服务提供者列表，configurations，routers，
4. 注册中心返回服务提供者地址列表给消费者，如果有变成，注册中心会基于长链接推送变更数据给消费者。
5. 消费者服务，从提供者地址列表中，基于负载均衡算法，选一条提供调用者进行调用，如果调用失败，在选另外一台。
6.服务消费者和提供者在内存中累计调用次数和调用时机哪，定时每分钟发送统计数据给 监控中心。

** dubbo 架构原理

分10层

第一层:service层，接口层， 给服务提供者和消费者来实现的，
第二层:config 层，配置层，主要对dubbo 进行各种配置 dubbo 相关配置，
第三层： proxy层，服务代理层，透明客户端的 stub 和服务单 skeleton， 调用的是接口，实现类没有，所以
得生成代理，代理之间在进行网络通讯，负载均衡等。
第四层： registry 层，服务注册层，负责服务的注册与发现。
第五层： cluster 层 集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务
第六层： monitor 层，监控层，对于 rpc 接口的调用次数和调用事件进行监控
第七层： protocol 层，远程调用层，封装 rpc 调用
第八层： exchange 层 信息交换层，封装请求响应模式，同步转换异步
第九层： trassport 层 网络传输层，抽象 mina 和 netty 为同一的接口
第十层： serialize 层，数据序列化成

** 服务的调用过程

1.调用过程从一个 proxy 开始， proxy 持有了一个 invoker 对象
2.触发 invoker 调用，调用过程需要 cluster
3.调用之前通过 directory 获取所有可调用的远程服务 invoker 列表， 接下来调用 LB 做负载均衡，选则一个可调用能够的 invoker。
4.这个invoker 在调用之前又会进入一个过滤器链， 通常是处理上下文，限流，计数等。
5.接着使用 client 做数据传输， 此时就会到 codec 接口做私有协议的构造。
6.构造完成之后，就对数据包做序列化， 传输到服务的提供者。
7.服务提供者收到数据包，也会使用 code 处理协议头一些 半包 年包等。处理完成孩子后再对完整的数据报文做饭序列化处理。
8.随后这个request 分配到线程此 进行处理，server 会处理这些request 根据请求查找对应的 exporter 


** 怎么实现动态感知服务下线的呢？

[[file:~/文档/StudyFile/Note/Image/f37ed9635ae4e6a27e246c1b95a20806.png][感知服务下线]]


服务订阅通常有 pull 和 push 两种方式

pull 模式需要客户端定时向注册中心拉取配置；
push 模式蚕蛹注册中心主动推送数据给客户端；

dubboZookeeper 注册中心采用是 事件通知与客户拉去的方式。服务第一次订阅的时候会将对应的目录全量拉去下来，然后在
订阅的节点注册一下 Watcher 一旦目录节点下数据发生变化， zookeeper 会通过 watcher 通知客户端，客户端接受到通知，
将会 重新拉去 该目录下的全量数据，并重新注册 watcher 利用这个模式 dubbo 服务就可以做到服务的动态发现。

zookeeper 提供了心跳检测功能，他会定时向各个服提供者发送一个请求（实际上建立一个 socket 长链接），如果长期没有响应就认为
服务挂了，将它剔除掉。

** dubbo 负载均衡策略
1.随机
2.轮询
3.活跃读-机器的活跃度来负载
4.一致性 hash -落到同一台机器

** dubbo 容错策略

1、failover cluster（故障转移模式）

失败自动转换，当失败时重试其他的服务器。（缺省）

用于读操作，但重试会带来更长的延迟。使用retries="2"来设置重试次数（不含第一次）

2、failfase cluster（快速失败模式）

快速失败，只发起一次调用，失败立即报错

用于非幂等性的写操作，比如新增记录
3、failsafe cluster（安全失败模式）

失败安全，出现异常直接忽略

用于写入审计日志等操作
4、failback cluster（故障恢复模式）

失败自动恢复，后台记录失败请求，定时重发

用于消息通知等操作
5、forking cluster（并行调用模式）

并行调用多个服务器，只要一个成功即返回。

用于实时性要求高的读操作，但是浪费更多资源。使用forks=“2”来设置最大并行数
6、broadcast cluster（广播模式）

广播调用所有提供者，逐个调用，任意一台报错则报错

用于通知所有提供者更新缓存或日志等本地资源

** dubbo 的动态代理策略有哪些？

默认使用的是 java ssist 动态字节吗生成，创建代理类，但是可以通过 spi 机制扩展配置自己的动态代理


** dubbo 都有哪些协议？

 1、dubbo 默认协议：

    单一 TCP 长连接，Hessian 二进制序列化和 NIO 异步通讯
    适合于小数据包大并发的服务调用和服务消费者数远大于服务提供者数的情况
    不适合传送大数据包的服务

2、rmi 协议：

    采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式
    如果服务接口继承了 java.rmi.Remote 接口，可以和原生 RMI 互操作
    对传输数据包不限，消费者和传输者个数相当

3、hessian 协议：

    底层 Http 通讯，Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现
    可与原生 Hessian 服务互操作
    通讯效率高于 WebService 和 Java 自带的序列化
    参数及返回值需实现 Serializable 接口，自定义实现 List、Map、Number、Date、Calendar 等接口
    适用于传输数据包较大，提供者比消费者个数多，提供者压力较大

4、http 协议：

    基于 http 表单的远程调用协议，短连接，json 序列化
    对传输数据包不限，不支持传文件
    适用于同时给应用程序和浏览器 JS 使用的服务

5、webservice 协议：

    基于 Apache CXF 的 frontend-simple 和 transports-http 实现，短连接，SOAP文本序列化
    可与原生 WebService 服务互操作
    适用于系统集成、跨语言调用

6、thrift 协议：

    对 thrift 原生协议 [2] 的扩展添加了额外的头信息
    使用较少，不支持传 null 值

** 什么是 dubbo  spi

