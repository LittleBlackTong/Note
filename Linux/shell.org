* 认识和学习 SHELL

** 为什么需要 shell 什么是 shell？

我们在使用计算机时，管理计算机的整个硬件时操作系统的核心（kernel），这个核心是需要被保护的！所以我们一般在使用计算的时候就只能通过 shell 来跟核心进行交互，让核心来帮我调度硬件。
什么是 shell （壳） ，先来了解一下计算的运行需要的内容。

1. 硬件：cpu、音响、ram、显示器
2. 核心管理程序：linux中的内核，也就是 kernel，各种设备的驱动程序
3. 应用程序：最外层应用，通过想计算机发送指令进行操作。

也就是当我们告诉计算机进行工作的时候，通过 shell（壳应用/外层应用）向计算机发送指令，由 kernel 来控制硬件正确工作

如图：
[[file:~/Documents/GitHub/Note/Image/%E5%A3%B3%E7%A8%8B%E5%BA%8F.png][壳程序]]

:: 能够操作应用程序的接口，都叫做壳程序，狭义的壳程序指的是命令行方面的软件。

** 学习 shell 的好处

- 大家都一样
:: 所谓的一通百通！！当学会了 shell 之后在操作计算时，使用的指令都是相同的，从而降低学习成本。
- 命令行比较快
:: linux 操作一般都是通过远程连接，连线时命令行的传输，比较快，通过学习 shell 也可以更深入的了解 linux
- linux 任督二脉
:: 通过 shell 可以更好的管理自己的主机，通过 shell 和 shell scripts 更好的管理主机的应用，达到随心管理的目的。

** 系统合法的 shell 和 etc/shells 功能

1. Bourne SHell（sh） 最早开发的
2. Sun 里头默认 C SHell  Linux C语言写的 
3. 商业常用 K SHell 
4. Linux 默认的 Bourne Again SHell （bash）

:: 登陆用户能够使用那些 shell 就是通过 etc/shells 进行检查的 场景/登陆 linux 检查用户使用的 默认的 shell  cat/etc/password

** shell 的变量功能

bash 中的变量是非常重要的一个功能， linux 中多用户多任务的环境，每个用户登陆系统之后都能够取得一个 bash，每个用户的变量设置都可能是不同的

*** 什么是变量？

数学中的 表达式  x= ay+b  y 就是一个变量，java 中的编程时定义的变量

*** 影响 bash 环境操作的变量
系统环境变量 PATH，我们操作各种指令时，比如 ls、cp 这些都在在 PATH 这个环境变量中设置的，在比如，安装 jdk 时候 需要设置环境变量 JAVA_HOME 和 PATH 中添加  java 
的运行指令。如果 PATH 当中没有这些指令，那么就会提示 command not found 的错误讯息了。 变量又分为系统变量和普通变量， 为了进行区分，将系统变量 设置为大写字符，
比如 JAVA_HOME、PATH 等

*** 程序设计脚本 shell script 中的大量应用

在设计 shell script 脚本时，比如某个文件的路径，用户名，这些在编写脚本时会大量的用到变量定义

*** 变量的取用和设置： echo，unset

读取变量时 通过 echo 命令就可以进行读出，只是在读取变量时 需要添加 $ 或者${val}的方式
取消变量设置 则通过 unset 将环境变量取消

*** 变量的设置

1. testval="123" 这里需要注意 = 号连接变量和变量值的时候不能有空格。
2. 变量只能是英文字符+数字，但是不能以数字开头
3. 可以在字符串中添加变量的取用，注意的是，单引号“‘” 无法将变量还原，““” 则可以将变量变量还原
4. 可以用一些 跳脱字符 \ 将特殊字符变成一般字符
5. 可以通过 $(指令) 获取变量
6. 若变量为扩展内容时，注意 使用 PATH=${PATH}:/java/bin
7. 如果该变量需要使用其他子程序执行， 需要 export 变量变成环境变量 如 maven：export M2_HOME=/usr/local/apache-maven-3.5.3

*** 环境变量

env 来获取系统的环境变量
set 指令来观察所有变量（包含环境变量与自定义变量）

$ 本身也是变量 代表当前shell 的线程代表 processID
？代表上一个指令的回传值 0 正常 错误 其他

*** 变量的有效范围

主要区分：环境变量和自定义变量
1.启动 shell 操作系统会分配一块记忆区给 shell 使用（环境变量），这块内存中的变量可以让子程序取用
2.如果父程序通过 export 功能可以让自定义变量的内容写到上边的记忆区（环境变量）
3.shell 启动另外一个 shell 离开父程序了， 则可以将记忆区块，（环境变量）中的内容倒入到自己的区块当中

说白了，环境变量哪里都能用，区域变量 子程序中自己用。

*** 文件系统及程序的限制 ulimit

设置当前登陆用户 使用的文件资源大小

** Bash shell 功能有哪些

1. 命令编修能力（history）
:: 通过 上/下 指令 可以找到 前/后输入的指令， 默认可以记录 1000 个 保存命令的文件位置 ～/.bash_history
2. 命令与文件的自动补全功能（tab）
3. 命令别名设置功能：（alias） 将复杂的指令设置别名 如：alias gp='git pull' unalias='gp' 
4. 程序化脚本 shell scripts （shell 和 shell script 是两种概念 ，shell script 是一种为shell 编写的教程程序） （定时任务脚本/linux 环境初始化/自动化部署脚本）
5. 万用字符（Wildcard） 查询符合字符的文件有哪些

万用字符符号
| 符号 | 意义                                                                                                                                  |
|------+---------------------------------------------------------------------------------------------------------------------------------------|
| *    | 代表“ 0 个到无穷多个”任意字符                                                                                                         |
| ？   | 代表“一定有一个”任意字符                                                                                                              |
| []   | 同样代表“一定有一个在括号内”的字符(非任意字符)。例如 [abcd] 代表“一定有一 个字符， 可能是 a, b, c, d 这四个任何一个”                  |
| [-]  | 若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的!                |
| [^]  | 若中括号内的第一个字符为指数符号 (^) ，那表示“反向选择”，例如 [^abc] 代表 ] 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。 |

bash 中的符号

| 符号 | 内容                                                               |
|------+--------------------------------------------------------------------|
| #    | 注解符号:这个最常被使用在 script 当中，视为说明!在后的数据均不执行 |
| \    | 跳脱符号:将“特殊字符或万用字符”还原成一般字符                      |
|      | 管线 (pipe):分隔两个管线命令的界定(后两节介绍);                    |
| ；   | 连续指令下达分隔符号:连续性命令的界定 (注意!与管线命令并不相同)    |
| ～   | 使用者的主文件夹                                                   |
| $    | 取用变量前置字符:亦即是变量之前需要加的变量取代值                  |
| &    | 工作控制 (job control):将指令变成背景下工作                        |
| !    | 逻辑运算意义上的“非” not 的意思!                                   |
| /    | 目录符号:路径分隔的符号                                            |
| >,>> | 数据流重导向:输出导向，分别是“取代”与“累加”                        |
| <,<< | 数据流重导向:输入导向 (这两个留待下节介绍)                         |
| ''   | 单引号，不具有变量置换的功能 ($ 变为纯文本)                        |
| ""   | 具有变量置换的功能! ($ 可保留相关功能)                             |
|      | 两个“ ` ”中间为可以先执行的指令，亦可使用 $( )                     |
| ()   | 在中间为子 shell 的起始与结束                                      |
| {}   | 在中间为命令区块的组合!                                            |

** 数据流重导向

1. 标准输出 标准错误输出

如图：
[[file:~/Documents/GitHub/Note/Image/%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C.png][指令执行]]

在执行指令的过程中，指令会通过文件读入，经过处理之后输入到屏幕上，standard output standard error output 标准输出和标准错误输出

| 名称         | 英文   | 指令   |
|--------------+--------+--------|
| 标准输入     | stdin  | <,<<   |
| 标准输出     | stdout | >,>>   |
| 标准错误输出 | stderr | 2>,2>> |

2. 命令执行的判断依据: ;,&&,||

- cmd1;cmd2 不考虑相关性，连续下达指令
:: 当指令执行完成之后就会立即执行下一个指令
- cmd1&&cmd2 两个指令分别执行
:: 当指令1正确执行，执行指令2 当指令1执行失败，不执行指令2
- cmd1||cmd2 单独执行一个指令
:: 当指令1执行正确，不执行指令2 当指令1执行失败，执行指令2

练习指令：ls /Users/crazy/Documents/test || mkdir /Users/crazy/Documents/test

** 管线命令（pipe）
*** 管线 ｜
bash 在执行指令的过程中会有数据进行输出，如果这个数据我们在使用的时候需要经过格式转换，那么就需要涉及到管线命令，符号是：｜
比如，我们查看某个文件夹下的内容，通过 less 指令翻动查看

管线命令的处理过程如图:
[[file:~/Documents/GitHub/Note/Image/%E7%AE%A1%E7%BA%BF%E5%91%BD%E4%BB%A4.png][管线命令]]

每个管线后面接收的第一个数据必定是指令，而且这个指令能够接收 standard input 的数据才行如 less、mord、grep
像 cp mv 这些指令就不是管线命令了 无法处理输入内容

*** 撷取命令：cut，grep
这玩意就是拿到一段数据，然后进行分析，取出我们想要的，一般是一段一段进行分析，没有通篇子搞的

1. cut 切

cut -d "分割符" -f 第几个内容
cut -c n-n 字符切割 第几个字符到第几个字符裁切

2. grep 分析

语法： grep [-acinv] [--color=auto] '查询内容' filename

 -c :计算找到 '搜寻字串' 的次数
 -i :忽略大小写的不同，所以大小写视为相同
 -n :顺便输出行号
 -v :反向选择，亦即显示出没有 '搜寻字串' 内容的那一行!
 --color=auto :可以将找到的关键字部分加上颜色的显示喔!
 

*** 排序命令： sort，wc，uniq

1. sort 排序 排序规则和字符形态有关，数字和文字的排序不同，排序的字符和字符编码有关

语法： grep [-fbm..] [file or stdin]
选项与参数:

 -f :忽略大小写的差异，例如 A 与 a 视为编码相同;
 -b :忽略最前面的空白字符部分;
 -M :以月份的名字来排序，例如 JAN, DEC 等等的排序方法;
 -n :使用“纯数字”进行排序(默认是以文字体态来排序的);
 -r :反向排序;
 -u :就是 uniq ，相同的数据中，仅出现一行代表;
 -t :分隔符号，默认是用 [tab] 键来分隔;
 -k :以那个区间 (field) 来进行排序的意思

2. uniq 相当于去重

语法：uniq [-ic]

项与参数:
 -i :忽略大小写字符的不同;
 -c :进行计数
 
3. wc 列出文件有多少行，多少字符

语法：wc [-lwm]

 -l :仅列出行;
 -w :仅列出多少字(英文单字);
 -m :多少字符;
 
4. 双向重导向： tee 将数据同时输出到文件和屏幕

语法：tee [-a] file

选项与参数:
 -a :以累加 (append) 的方式，将数据加入 file 当中!

*** 字符串转换命令： tr,col,join,paste,expand

1. tr 删除一段讯息中的文字，或者进行文字讯息替换

语法 tr -[ds] set1

选项与参数: 
 -d :删除讯息当中的 SET1 这个字串;
 -s :取代掉重复的字符!
 
2. col 将 tab 键转化为空白

语法： col [-xb]

选项与参数:
 -x :将 tab 键转换成对等的空白符

3. join 处理两个文件，当有相同的数据 的那一行，才将他加在一起

语法：join[-ti12] file1 file2

选项与参数:
 -t :join 默认以空白字符分隔数据，并且比对“第一个字段”的数据，
 如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个!
 -i :忽略大小写的差异;
 -1 :这个是数字的 1 ，代表“第一个文件要用那个字段来分析”的意思;
 -2 :代表“第二个文件要用那个字段来分析”的意思。
 
4.paste 将两行贴在一起，中间用[tab] 隔开而已

语法：paste [-d] file1 file2

选项与参数:
 -d :后面可以接分隔字符。默认是以 [tab] 来分隔的!
 - :如果 file 部分写成 - ，表示来自 standard input 的数据的意思。
 
5.expand 将 tab 按键转化成空白键

语法：expand [-t] file

 -t :后面可以接数字。一般来说，一个 tab 按键可以用 8 个空白键取代。
 我们也可以自行定义一个 [tab] 按键代表多少个字符呢!
 
*** 分区命令 split

将大文件，依据文件大小或者行数来进行分区，将大文件分区成为小文件

语法： split [-bl] file PREFIX

 -b :后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等;
 -l :以行数来进行分区。
 PREFIX :代表前置字符的意思，可作为分区文件的前导文字。
 

*** 参数代换：xargs

将标准输入的文本作文参数  x 代表的 乘号 args 则是参数

语法：xargs [-0epn] command

选项与参数:
-0 :如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数
可以将他还原成一般字符。这个参数可以用于特殊状态喔!
-e :这个是 EOF (end of file) 的意思。后面可以接一个字串，当 xargs 分析到这个字串时，
就会停止继续工作!
-p :在执行每个指令的 argument 时，都会询问使用者的意思;
-n :后面接次数，每次 command 指令执行时，要使用几个参数的意思。
当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔!

