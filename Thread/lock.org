* Java 锁相关知识点

** 什么是锁

多线程的情况，多个线程操作同一个资源争抢，导致数据不一致。为了解决这个问题，有了锁的这个概念

** 对象 对象头结构

对象有三个部分  1. 对象头 2. 实例数据 3. 对齐填充

对齐填充主要是为了满足 对象大小必须是 8bit 的大小 填充的无用数据

实例数据 则是保存 对象的属性方法等信息

对象头则储存一些额外的数据记录运行时的状态

markword  和  classPoint 

classPoint 就是对象的指针 

markword 则记录了一些状态


|          |                      |       |          |            |          |
|----------+----------------------+-------+----------+------------+----------|
| 锁状态   | 25bit                |       | 4bit     |       1bit |     2bit |
|          | 23bit                | 2bit  |          | 是否偏向锁 | 锁标志位 |
| 无锁     | 对象的 hashcode      |       | 分代年龄 |          0 |       01 |
| 偏向锁   | 线程id               | epoch | 分代年龄 |          1 |       01 |
| 轻量级锁 | 指向栈中锁记录的指针 |       |          |            |       00 |
| 重量级锁 | 指向重量级锁的指针   |       |          |            |       10 |
| GC标志   | 空                   |       |          |            | 11       |


锁的四种状态

无锁-> 偏向锁-> 轻量级锁-> 重量级锁 从低到高

偏向锁： 根据锁的标志位判断是否是有有锁的 如果是 01 那么判断前边的bit 是否是1  如果是 1 那么是偏向锁，否则就是无锁，如果偏向锁，那么取前
23 bit 中的 线程 id 来判断当前线程是否是 识别，或者说是偏爱的线程，就直接获取锁

轻量级锁： 如果对象锁的标志位 为 00 说明该对象是轻量级锁，获取该锁的线程会在 jvm栈中开辟一个 lockrecord 的记录。 lockRecord 分别记录
该对象的 markword 的副本， 以及 owner指针指向该 对象。  然后对象的 前30 个bit 生成一个指针，指向 线程的 lockRecord 这样 线程和对象就行了绑定


其他对象想获取 该锁 那么需要进行自旋等待， cpu 空转， 适应性自旋。

重量级锁： 通过 monitor 进行判断，锁的登记最高。

** CAS compareAndSwap  比较并替换

乐观锁

当两个线程同时操作统一系统资源时，对资源进行争抢，比如一个对象，他的资源状态 是0 说明没有线程对他进行操作，这时，两个线程同时进行争抢，
将对象状态更改为 1 另外一个线程则 进行自旋等待。

cas 是一种算法



** ReentrantLock

