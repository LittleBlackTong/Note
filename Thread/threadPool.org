* 线程池相关知识点

**  什么是线程池

线程池是一种池化思想，在程序启动时，内存中存放需要使用未使用的线程池，池中的线程执行调度由线程池任务管理器来
通过线程池可以避免对象的重复创建，提高效率

** 线程池的好处

1.减少对象的创建销毁次数，每个工作线程都可以被重复使用，可以执行多个任务。
2.运用线程池能有效的控制住最大并发数，可以根据系统的承受能力，调整线程池中工作线程的数目
3.对线程进行一些简单的管理，比如延时执行，定时循环执行，通过线程池都能够很好的实现。

** 线程池的四个基本组成部分

1. 线程池管理器；用于创建并管理线程池，包括创建线程池，销毁线程池，添加新的任务等
2. 工作线程；线程池中的线程，在没有任务时出于等待状态，可以循环的执行任务；
3. 任务接口；每个任务必须实现的接口，以工作线程调度任务执行，它主要规定了任务的入口，任务执行完收尾工作，任
务的执行状态等。
4. 任务队列；用于存放没有处理的任务。提供一种缓冲机制。

** 创建一个线程池需要的参数

1.corePoolSize （线程池基本大小），当提交一个任务时线程池会创建一个线程来执行任务，即使其他的空闲的基本线程能够执行
任务也会去创建，如果调用了 prestartAllThreadCoreThreads 方法，线程池会提前创建并启动所有基本线程
2.maximumPoolSize（线程池最大大小）；线程池允许创建的最大线程数，如果队列满了，并且已创建的线程数小于最大线程
则线程池会再创建新的线程执行任务。如果使用了无界任务队列，那么就没什么效果了
3.runnableTaskQueue（任务队列） 用于保存等待执行的任务的阻塞队列。
4.ThreadFactory；用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字用于 debug 定位
5.RejectedExecutionHandler（拒绝策略）；当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种拒绝策略，来处理
任务
6.keepAliveTime（线程活动保持时间）；线程池的工作线程空闲之后，保持存活的时间，所以如果任务很多，并且每个任务执行
的时间比较短，可以调大这个，提高线程的利用率。
7.TimeUnit（线程保持活动的时间单位）；Day hours miutes 等


** 如何向线程池提交任务

通过 execute（） 和 submit（）两个方法向线程池提交任务

** 线程池的关闭

我们可以通过 shutdown 或 shutdownNow 方法关闭线程池，不过它们有所不同
shutdown 的原理是只是将线程池的状态，设置成 shutdown 状态，然后中断所有没有正在执行，任务的线程
shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrup 方法来中断线程，所以无法响应中断
的任务可能永远无法终止。 

** 三种阻塞队列

arrayBlockingQueue 基于数组的先进显出队列
linkedBlockingQueue 基于链表的先进先出队列，
synchronousQueue 无缓冲的等待队列

** 四种拒绝策略

1. AbortPolicy ；丢弃任务并且抛出异常
2. DiscardPolicy ； 丢弃任务但是不抛出异常
3. DisCardOldSetPolicy； 丢弃队列最前面的任务，然后提交心来的任务
4. CallerRunPolicy； 由调用线程（提交任务的线程）主线程处理该任务

** 四种线程池
1. cacheThreadPool 可缓存的线程池
:: 线程数无限制，有空闲线程则复用空闲线程，若无空闲线程则新建线程 一定程序减少线程的频繁创建，减少开销

2. fixedThreadPool 鼎昌的线程池
:: 可控制线程的最大并发数，同时执行的线程数，超出的线程会在线程队列中等待

3. ScheduledThreadPool 定时线程池
:: 定时线程池，支持定时及周期性的任务执行

4. SingleThreadExecutor 但线程化的线程池
:: 有且仅有一个线程执行任务，线程的执行顺序按照入队的顺序执行。

** 线程池的 五种状态

1. 线程池的初始化状态是 RUNNING 能够接收新任务，以及对已添加的任务进行处理。
2. 线程池处于 SHUTDOWN 状态， 不接受新的任务，但是能处理已添加的任务。调用线程池的
shundown（）接口时，线程池由 RUNNINT -> SHUTDOWN
3. 线程池处于 STOP 状态时，不接受新的任务，不处理已添加的任务，并且会处理正在处理的任务
调用线程池的 shutdownNow 接口时，线程池由 RUNNINT 或 SHUTDOWN-> STOP
4. 当所有任务已终止， ctl 记录的任务数量为 0 线程池会变为 TIDYING 状态 ，变成 TIDYING 状态时，会执行
钩子函数 terminated（） 在ThreadPoolExecutor 类中是空的， 若用户想在线程池变成 TIDYING 状态时，
进行相应的处理，可以重写 terminated 函数来实现。
5.当线程池在 SHUTDOWN 状态下，阻塞队列为 空，并且线程池中执行的任务也为空时，就会 SHUTDOWN->TIDYING
6.当线程池在STOP 状态下，线程池中的执行的任务为空时 就会由 STOP-> TIDYING 线程池彻底终止 就变成 TERMINATED 
状态 ，线程池是 TIDYING 状态是 调用 terminated（） 之后就会变成终止状态。

** 如何释放核心线程

当线程超时可以进行释放

allowCoreThreadTimeOut 设置为 true
