* Java IO 模型

** 阻塞IO 模型

最传统的一种IO 模型，用户在读写数据的过程中会发生阻塞现象，当用户发出IO 之后，内核就会查看
数据是否就绪，如果每就绪，就会等待到数据就绪，而用户线程就会处于阻塞状态，用户线程交出cpu，当
数据就绪了之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程解除 block 状态。
电影的例子 data=socket.read (); 如果数据没有就绪，就会一直阻塞在read 方法。

** 非阻塞 IO 模型

当用户发起read 操作之后，不需要等待，而是马上得到一个结果，如果结果是 error，它直到数据没有准备好，
于是再次发送read 操作。一旦内核中的数据准备好。用户也再次发送read 请求，那么它马上就将数据拷贝到了，
用户线程，然后返回。所以事实上在非阻塞IO 模型中，用户线程需要不断的询问内核数据是否就绪，非阻塞IO 不会交出cpu，
而是一直占用cpu询问内核。

```
data = socket.read ()
if (data!=error) {
处理数据
break;
}
```

会导致一个问题 cpu 占用非常高。

** 多路复用IO 模型。
多路复用 IO 模型是目前使用的比较多的 javaNIO 就是 多路复用，多路复用IO模型中会有一个线程，区轮询socket状态，
只有当 socket 真正有读写事件时。才真正调用实际的 IO 读写操作。只需要有一个线程来管理socket，这样大大减少了资源。在
java NIO 中是通过 selector.select () 去查询每个通道是否有到达事件的。如果没有事件，则一直阻塞在那里，因此这种方式
会导致用户线程阻塞。多路复用IO 模式，通过线程就可以管理多个socket，只有当socket 真正有读写在进行实际的读写操作。

多路复用IO 模型比非阻塞IO 模型效率高的是因为 非阻塞IO中 不断询问 socket 状态时 是用户线程进行的，多路复用IO 模型中
轮询socket 状态是 内核进行的。这个效率要比用户线程高的多。

** 信号驱动模型

用户发起IO 之后 会给对应socket 注册一个信号驱动函数，用户线程就会继续执行，当内核数据就绪的时候，会调用这个函数，用户线程接口
函数的信号之后，调用IO 读写操作。

** 异步IO模型

异步IO 模型是最理想的IO 模型，用户发起read 操作了之后，就立刻开始做其他事，另一方面从内核的角度，接受 read 之后就会立刻返回。
说明read 请求成功了，不会让用户线程block 然后等待内核数据准备完成，将数据拷贝到用户线程，当这一切都完成了之后，内核会给用户线程
发送一个信号，告诉它read 操作完成了， 也就是用户线程完全不需要知道整个IO 如果操作的。只需要用户线程发起请求，当接口内核返回成功信号的
时候 IO 操作已经完成，可以直接区使用数据。


** Java NIO

java nio 主要有三部分，channel buffer selector，传统IO基于字节流或者字符流。而IO基于channel 和buffer 缓冲区进行操作。数据
总是从 通都读取到缓冲区 或者从缓冲区写到通道中。 selector 用于监听 多个通道的事件（打开链接，数据到达），单线程可以监听多个通道。
NIO 和传统IO 最大的区别是，一个面向的是流的，NIO 是面向缓冲区的。

** NIO 的缓冲区

java IO 是面向流的，每次从流中读取一个或者多个字节，直到读取完全部，没有被缓存在任何地方.
NIO的缓冲向导方法不同，数据读取到一个他稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了，
处理过程中的灵活性。 但是他还需要检查缓冲区是否包含需要的数据，而且需确保更多的数据读入缓冲区时，不需要覆盖缓冲区里
尚未处理的数据。

** NIO 是非阻塞

java IO 是阻塞的，读写过程线程被阻塞，直到数据完全写完。 NIO 是非阻塞的，一个线程从通道发送请求数据，他能得到目前的可用数据
但是他仅能得到目前的可用数据，没有数据时就什么都不会获取，不会保持线程阻塞，直至数变得 可以读取之前，线程可以做其他事情，非阻塞写也是。

** channel 

channel 和 stream 类似 不过 stream 是单向的，channel 是双向的，既可以读也可以写。
主要实现有 
1.fileChannel
2.datagramChannle
3.socketChannel
4.serverSocketChannel

** buffer

缓冲区，实际上是一个容器，连续的数组 channel 提供从文件网络读取数据渠道，但是读取和写入都必须经由 buffer

client->buffer->channel <-> channel->buffer->server

client 到server 的数据流向

** selector

selector 类是 NIO 核心 能够检测多个注册通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件继续宁相应的相应处理。
这样只用一个单线程就可以管理多个通道，管理多个链接。不用为每个链接都创建一个线程。避免线程之间上下文的开销。

