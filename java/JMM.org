* JMM

** 什么是 JMM

JMM 是java 内存模型，不同的应将厂商，和不同的操作系统，内存的访问有一定的差异。JMM 就是为了屏蔽各种硬件，和系统访问内存差异，
以实现让java 程序在各种平台上达到一致的并发效果的。

Java 内存模型规定“所有变量都是存储在主内存的”，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作 内存。
线程的工作内存保存了该线程用到的变量 和主内存副本拷贝，线程对变量的操作都是在工作内存中完成的，线程不能直接操作主内存中的变量

线程 A <-> 工作内存，主内存副本拷贝<->
线程 B <-> 工作内存，主内存副本拷贝<-> JMM 控制<->主内存
线程 C <-> 工作内存，主内存副本拷贝<->

每个工作内存都是独立的，只能在工作内存中进行，然后刷到主存。这是java 内存模型定义线程的基本工作方式。

** JMM 定义了什么

原子性，可见性，有序性，java 并发的基础。

*** 原子性

只操作不可分割的，不可中断的，一个线程在执行的过程中不会被其他线程干扰。
```
int i =2; 可以
int j=i; 两步操作，不可以
i++; 不可以
i=i+1； 不可以
```
JMM 只能保证基本的原子性，如果要保证代码块的原子性 提供了 monitorenter 和 monitorerexit 两个字节吗指令，也就是 synchronized 关键字

*** 可见性

可见性是指，当一个线程修改共享变量的值，其他线程就能立即直到被修改了， java 利用 volatile 关键字来提供可见性的。当变量被 volatile 关键字修饰时，
这个变量会被立即刷新到主内存，当其他线程需要读取该变量时，回去主内存读取新值。普通变量不能保证这一点。

除了 volatile 关键字之外 final 和 synchronized 也能实现可见性。

synchronized 原理是执行完，进入unlock之前必须将共享变量同步到主内存里。
finable 字段 一旦初始化完成，其他线程也都是可见的。

*** 有序性

在java 中，可以使用 synchronized 或者 volatile 保证多线程之间的操作的有序性。

volatile 关键字是使用内存屏障达到禁止指令重排，保证有序性。

synchronized 原理是 线程lock 之后必须unlock 其他线程才可以重新lock，代码快变成了串行。

*** 八种内存交互操作


                              3.load        4.use
                             <----> 工作内存 <------> 线程 
1.lock   2.read    
主内存 <-------> load/store   <----> 工作内存 <------> 线程 
8.unlock 7.write
                             <----> 工作内存 <------> 线程 
                            6.store         5.assign


1. lock（锁定） 用于主内存中的变量，把变量的标识成线程独占的状态
2. read（读取） 用于主内存中，把变量的值从主内存传输到线程的工作内存中以便下一步的 load 操作
3. load（加载） 作用于工作内存变量，把read读取的变量放入到工作内存的变量副本中。
4. use（使用） 作用于工作内存变量，把工作内存中的变量传输到执行引擎，当虚拟机需要使用到变量的值，字节吗会执行这个操作。
5. assign（赋值） 作用工作内存中变量，从执行引擎中接受到赋值给工作内存中的变量副本中
6. store（存储） 作用于工作内存变量，它把一个工作内存中的变量传递给主内存。以便后续的 write 使用。
7. write（写入） 作用于主内存，把store 操作的工作内存的变量放入主内存当中。
8. unlock（解锁） 用作主内存变量把它从一个锁定状态释放出来，释放后其他变量才可以被其他线程锁定使用。

*** 内存的交互规则

1.不允许 read load store write 操作单独出现，也就是 read 之后必须load  store 操作之后必须write。
2.不允许线程丢弃最近的assign操作，即工作内存变量更改之后必须告知主内存。
3.不允许线程将没有assign的数据从 工作内存同步到主内存
4.一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施 use store 操作之前，必须经过 load 和assign 操作。
5.一个变量同一事件只能有一个线程对其进行lock 操作，多次lock 之后必须执行相同次数的unlock 才可以解锁
6.如果对一个变量进行lock 操作，会清空所有工作内存中的此变量的值，在执行引擎使用这个变量前，必须重新load 或者assign 操作初始化变量的值。
7.如果一个变量没有被lock 就不能对其进行unlock 操作，也不能unlock 一个被其他线程锁住的变量。
8.一个线程对一个变量进行unlock 操作之前，必须把这个额变量同步回主内存中。

** Volatile 关键字

1. 保证线程之间变量的可见性
2. 禁止 cpu进行指令重排

volatile 修饰的变量，当一个线程改变了该变量的值，其他线程是立即可见的。普通变量则需要重新读取才能获得最新的值。

** volatile 一定能保证线程安全么

不能。可见性不能保证原子性，count++ 不是原子操作，会当作三步，先读取count 的值，然后+1 然后在赋值回去count 变量。需要保证线程安全的化需要加锁。

** 禁止指令重排

as-if-erial 语义，不管怎么重排序，单线程的程序执行结果是不能被改变的。
为了使指令更加符合 cpu 的执行特性，最大限度的发挥机器的性能，提高代码的执行效率，执行指令的顺序和代码逻辑顺序，不一致，
这个过程叫做指令重排序。

源代码-> 编译器重排序-> 指令级重排序->内存系统重排序-> 最终的指令执行顺序

指令重排在单线程的情况是没有问题的，不会影响执行结果，但是多线程环境下就不能保证一定不会影响执行结果了。“多线程
环境需要禁止指令重排”


volatile 关键字禁止指令重排有两层 意思。

当程序执行到 volatile 变量的读操作或者写操作时在其前边的更改全部已经进行，而且对后边的操作可见，在其后边的操作 肯定没有进行。
在进行指令优化时，不能将在对 volatile变量访问的语句放在其后边执行，也不能将 volatile 变量后边的语句放在前边执行。

```
private static int a;
private static int b;
private static volatile int k;

private void hello () {
1.a = 1;
2.b = 2;
3.k = 3;
4.a = 4;
5.b = 5;
}
```

必须保证 1 2  执行实在k赋值前边， k 3 必须在 45 前边 但是 1，2 和 4，5 本身的顺序可以不用保证。

** 禁止指令重排的原理是什么

内存屏障，内存屏障分为几类，

1. LoadLoad 屏障; 对于这样的语句 load1 LoadLoad load2。 在load2以及后续读取操作的数据被访问前，保证 load1要读取的数据被读取完毕。
2.StoreStore 屏障； 对于 store1 StoreStore store2 ，在sotre2以及后续写入执行前保证 store1的写入操作写入完毕。
3.LoadStore 屏障； 对于 load1 LoadStore store2，在store2 以及后续写入操作之前，保证load1的读取操作读取完毕。
4.StoreLoad 屏障； 对于 store1 StoreLoad load2，在load2 以及后续的读取操作执行前，保证store1的写入操作执行完。


在每个 volatile 读操作后插入 LoadLoad 屏障， 在读操作后加入 LoadStore 屏障
---------------------------------------------------------------
volatile 读

LoadLoad 屏障 -> 禁止下边的所有普通读操作和上边的 volatile 读重排序

LoadStore 屏障-> 禁止下边的所有写操作和上边的volatile 读重排序
---------------------------------------------------------------



在每个 volatile 写操作，前边加StoreStore 屏障，后边加上 StoreLoad 屏障
---------------------------------------------------------------
StoreStore 屏障 -> 禁止上边所有普通的写操作，和下边的 volatile的写重排序
volatile 写
StoreLoad 屏障 ->  禁止下边的读操作，和 volatile 的写操作重排序。
---------------------------------------------------------------
