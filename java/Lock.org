* Java 锁

** 乐观锁

乐观锁是一种思想，认为读多写少，并发低，每次线程来拿数据，都是认为不会修改，在更新的时候会判断一下有没有其他线程来更新数据
写的时候先读取数据版本号，然后加锁操作，如果失败，则需要重复读-比较-写 的过程，
java 中的乐观锁，都是通过 cas 的机制来实现的，cas 是一种原子操作比较当前的值是否和传入的值 相同，如果相同则更新否则失败。

** 悲观锁
则是悲观事项，任务写多读少，并发的时候每个线程都会修改这个数值，所以每次读写数据的时候都会上锁，别人想读写这个数据的时候就会阻塞，
直到拿到锁，java 中的悲观锁 就是 synchronized AQS 框架下的锁，都是先尝试 cas 乐观先获取锁，获取不到，才会转化成悲观锁。如 retreenlock


** 自旋锁
自旋锁道理很简单，就是持有锁的线程可以在很短的时间内释放锁，那么可以让其他等待锁竞争的线程就不需要在 内核和用户太之间转换，
他们只需要等一等 （自旋），持有锁的线程释放锁了之后就可以立即获取锁这样可以避免用户线程和内核的切换。

自旋锁是消耗cpu 的，让cpu 做无用功，所以需要设置一个最大自旋时间。


** Synchronized 同步锁

他是悲观锁，也是可重入锁，

1. synchronized 作用方法时锁住的是对象实例，
2. 当用作静态方法的时候 锁住的是 class 实例，因为class相关数据是放在 永久带的，永久带是共享的，所以静态方法锁是一个全局的锁，会锁住
所有调用该方法的线程。
3.sychronized 作用对象实例的时候，锁住的是以该对象为锁的代码快，他又多个队列，当线程一起访问某个对象的监视器的时候，监视器会将线程放入不同的容器
里。

** synchronized 的核心组件
在很短的时间内释放锁，那么可以让其他等待锁竞争的线程就不需要在 内核和用户太之间转换，
他们只需要等一等 （自旋），
1. wait set 那些调用了 wait方法的阻塞线程会放在这个里。
2. contentionList 竞争队列，所有请求锁的线程会放在这个队列里
3. entry list 有资格成为候选资源的线程会放在这个队列里，
4. ondeck，任意时刻，最多只有一个竞争锁资源的线程被成为 ondeck
5. owner 拿到锁的线程被成为 owner
6. ！owner 当前释放锁的线程

** synchronized 特点 
1.synchronized 锁是非公平锁，线程先进入 contentionList 中会先自旋尝试获取锁，获取不到就直接进入 contentionList，
对先进入队列的线程是不公平的，而且自旋的时候有可某个线程直接 ondeck 抢到线程锁资源。

2。每个对象都有monitor 对象的，加锁就是在竞争monitor 对象，代码块加锁则是 在前后分别有 monitorenter 和 monitorexist 通过标记位置来实现的。

3.synchronized 是重量级锁，需要调用系统相关接口，有可能加锁，比有用操作更耗时，

4.jdk 1.6 之后做了很多优化，适应自旋，锁消除，轻量锁偏向锁，1.7 和1.8 也对进行了优化，引入了偏向锁和轻量锁，对象头中有标记为，不再需要系统加锁了，

5.锁可以从偏向锁，升级到轻量锁，再到重量锁，这个过程叫做锁膨胀。

