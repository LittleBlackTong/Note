* Java  多线程


** Java 线程实现/创建方法

1. 继承 Thread 类本质上实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程
的唯一方法就是通过Thread 类的start（）方法，start（）方法是 native 方法，将启动一个新的线程
并且，执行run（）方法

2. 实现 Runnable 接口，如果自己的类已经 extends 另一个类，就无法直接extendsThread 这时可以实现一个
Runnable 接口

3. ExecutorService Callable<Class> Future 有返回值线程

有返回值的任务必须实现 Callable 接口 类似的 无返回值的必须实现Runnable 接口，执行 callable 任务后，
可以获取一个 future 的对象，在该对象上调用 get 就可以获取到 callable 任务，返回的 object 了，在结合线程池接口
 ExecutorService 就可以实现有返回结果的多线程


4. 基于线程池的方式

```
threadPool.execute (new Runnable () {
    @Override
    public void run () {

    }
})
```


** 四种线程池

Java 里面线程池的顶级接口是 Executor 但是Executor 不是一个线程池 而只是一个执行线程的工具 ，整整的线程池接口是 ExecutorService


1. newCachedThreadPool

调用 execute 将重用以前构造的线程，如果现有线程没有可用的，则创建一个新线程并添加到线程池中。终止
从缓存中移除那些已有60秒中未被使用的线程。

2. newFixedThreadPool

创建一个可重用固定线程数的线程池。以共享无界队列方式来运行这些线程

3. newScheduledThreadPool

创建一个线程池，它可安排在给定时延迟后运行命令，或者定期的执行。

4. newSingleThreadExecutor

线程池只有一个线程，线程池可以在线程死后，重新启动一个线程来替代原来的线程继续执行下去。

** 线程的生命周期

线程经过 新建（new） 就绪（runnable） 运行（running） 阻塞（blocked） 死亡（dead） 五种状态，当线程启动之后它不可能一直霸占cpu
独自运行，所以cpu 需要在多条线程之间切换，于是线程状态也会多次在运行 阻塞之间切换。

1. 新建状态 当用new 创建一个线程了之后线程就处于新建状态，此时仅有 JVM 为其分配内存，并初始化其他成员变量的值。
2. 就绪状态，当线程调用了 start（）方法之后 ，该线程处于就绪状态，java 虚拟机会为其创建方法调用斩和程序计数器等待调度运行，
3. 运行状态，就绪状态的线程获得 cpu 开始执行 run（）方法的线程执行提，该线程处于运行状态
4. 阻塞转该，因为某种原因放弃了 cpu 使用权，也即让除了 cpu timeslice 暂时停止运行知道线程进入可运行状态， 才会有机会再次获得 cpu timeslice 转到
running 状态
  （1） 等待阻塞，运行的线程执行 o.wait ()方法，JVM 会把该线程放入等待队列中。
  （2） 同步阻塞，运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM 会把该线程放入锁池中。
  （3） 其他则色， 运行的线程执行 thread.sleep（ms） 或者 t.join（）方法， 或者发出了 IO 请求 jvm会把线程设置为阻塞状态，
等 sleep（）状态结束，或者 join 线程终止或者超时，或者io处理完毕，线程重新传入可运行状态。

5. 线程死亡，线程会以三种方式结束，结束就是死亡状态。
  （1） run（）或者call （） 方法结束线程正常结束
  （2） 异常结束，线程抛出一个未捕获的 Exeception 或者 Error
  （3） 调用 stop 直接调用该线程的 stop （）方法来结束该线程，该方法通常容易导致死锁，不推荐使用， 而且调用 stop 了之后 线程持有的锁会突然释放，会出现数据不一致性。
  （4） interrupt 方法结束线程，其中有两种情况， 线程处于阻塞状态，调用 interrupt 方法 不会立刻结束线程，而是捕获 interruptException 异常之后，通过 break 
来跳出循环，结束正常的run 方法。 

** sleep 与 wait 区别

1.sleep 方法属于 thread类 wait 是对象的方法，sleep 方法导致程序停止指定的时间让出 cpu 给其他线程，但是监控状态依然是保持的，当指定的时间，又会
又会恢复运行状态，


2. sleep 方法中 不会释放 对象锁
3.而当调用对象wait（）方法线程会放弃对象锁进入等待此对象的等待锁定池中，只有此对象调用 notify（）方法后，本线程才进入对象锁定池获取对象的锁
进入运行状态

** start 方法与 run 方法的区别

1.start 方法来启动线程，实现真正的多线程运行。通过调用 start 方法 并没有运行，只是进入了就绪状态
2.run 相当于线程的线程体，包含了要执行这个线程的内容，线程进入了运行状态，开始运行run 函数中的代码，run 方法结束 线程结束
