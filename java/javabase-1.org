一、覆盖与重载

1.相同点
> 覆盖与重载类似,都是具有相同的名字
2.不同点
> 覆盖与被覆盖的同名方法分别属于不同的父类-子类,而重载同名方法是在同一类中
> 覆盖与被覆盖的同名方法具有相同的参数列表和返回值,而重载同名方法必须有不同的参数列表
> 覆盖方法的访问与不能比被覆盖的访问域更窄而重载没有访问域限制

二、基本数据类型

1.四类八种
> 整数类型:byte short int long
> 浮点类型:float double
> 字符类型:char
> 逻辑类型:boolean

2.所占的字节长度
> byte 8
> short 16
> int float 32
> long double 64

三、 op++ 与 ++op 的区别

> op++ 先计算 op 的值然后载进行加 1 操作
> 如: a = 1;c = a++ ;c 的值为 1
> ++op 先对 op 进行加运算 然后在得到值
> 如: c = ++a; c 的值为2

四、多态存在的条件

> 不同的对象对同一行为的不同响应
>  1. 要有集成或者实现
>  2. 要有重写
>  3.父类引用指向子类对象

五、类型转换规则
> 低优先级的向高优先级的类型进行自动转换,反之则进行强制类型转换

六、 &  |  ^  的用法

> & 按位与 数字转换成二进制,每一位都相同返回 1 否则返回0
> 如: 110 & 010 = 010 = 2
> | 按位或 数字转换成二进制,有一位相同就返回 1 否则返回0
> 如: 110 | 010 = 110 = 6
> ^  数字转换成二进制 ,只有当两位结果不同时返回 1 否则返回 0 
> 如: 110 ^ 010 = 100 = 4

七、 instanceof 
> 判断对象类型 == < > 操作符类似

八、面向对象的三大特性
> 封装,继承,多态

九、类的定义
> [修饰符] class 类名{
>  成员变量
>  成员方法
>  内部类
> }
> 构造方法/构造器
> 1. 方法名与类名相同
> 2. 不含返回值类型
> 3. 一般权限为public
> 如果生命了带参数的构造器,系统不会在添加默认的构造器,所以如果想添加参数构造器一定要添加默认构造器

十、引用数据类型的转换
> 上溯造型:
> 向上转型-子类继承父类,自动转换;前提-具有继承或者实现的关系,向上转型损失了子类扩展的属性和方法,仅可以使用继承的属性和方法
> 下溯造型:
> 向下转型-将父类对象转化为子类对象,曾经向上转型的对象,才能向下转型,对象不允许未经过向上转型而直接进行向下转型.

十一、 成员变量和局部变量的区别:
> 1. 类的位置中不同
>  成员变量:类的方法外
>  局部变量:在方法中定义
> 2. 内存的位置不同
>  成员变量:在堆内存中
>  局部变量:在栈内存中
> 3. 声明周期不同
>  成员变量:随着对象的创建而存在,随着对象的消失而消失
>  局部变量:随着方法的调用而存在,随着方法的调用完成而消失
> 4. 初始化值不同
>  成员变量: 有默认初始化值
>  局部变量: 没有默认的初始化值,必须定义赋值,然后才能使用

十二、 final 关键值
> 1. 类:该类不能被继承
> 2. 变量: 常量不能被赋值
> 3. 方法: 不能再子类中被覆盖,不能修改

十三、堆和栈的区别
> 栈:栈的读取速度比堆快，效率高，栈内保存的基本数据类型的局部变量 和对象的引用值
> 堆: 队可以保存那些对空间要求比较大的变量。如对象的属性和数组元素，堆内存中开辟空间,只能通过内存的分配操作符号 new，凡是出现关键字new的地方必定分配了一个堆内存

十四、访问权限

|  | private  | default | protected | public |
| --- | --- | --- | --- | --- |
|同一类  | * |*  |*  |*  |
|同一个包的类  |  | * |*  |*  |
|不同包中的子类  |  |  | * | * |
|其他包中的类  |  |  |  | * |

十五、块的加载顺序:
> 1. 父类静态块
> 2. 子类静态块
> 3. 父类普通块
> 4. 父类构造器
> 5. 子类普通块
> 6. 子类构造器
> 同时创建多个对象的时候只调用一次静态块,块随着类的加载自动运行一次
