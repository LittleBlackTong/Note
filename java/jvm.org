* JVM 内存区域

** 线程

线程指的是程序执行过程中的一个线程实体，JVM 允许一个应用并发执行多个线程。
Java 线程与原生操作系统负责调度多有线程有直接的映射关系，当线程本地存储，缓冲区分配，同步对象，
栈，程序计数器准备好了以后就会创建一个操作系统原生线程。java线程结束，原生线程随之被收回。操作系统负责调用所有线程，看，，
并且分配到cpu 上，原生线程初始化完毕，就会调用java 线程的 run 方法，当线程结束时，释放原生
线程，和java 线程的所有资源。

** jvm 内存区域

jvm 内存区域主要分为，线程私有区域【程序计数器，虚拟机栈，本地方法区】 线程共享区域【堆，方法区】

线程私有区域，生命周期与线程相同，依赖用户线程启动/结束，每个线程都与炒作系统直接映射，因此这部分内存
区域跟本地线程 生/死对应

线程共享区域，与虚拟机启动/关闭而创建和销毁。

直接内存并不是 jvm 运行时数据区的一部分，但是也会被频繁的使用： 在 jdk 去。4引入 NIO 提供了
channel buffer 的IO 方式，可以用 Native 函数库直接分配堆外内存。避免在 java 堆和native 堆中来回复制数据，因此一些场景中
可以显著提升性能。


*** 方法区 

运行常量池永久代，主要用于存储被 JVM 加载的 类信息，常量，静态变量，即时编译器编译后的代码等数据。 
运行常量池是方法区的一部分， 主要保存 类的版本，字段方法，接口等描述的信息。

*** 虚拟机栈

栈帧（局部变量表，操作数栈，动态链，方法出口）

是描述java 方法执行的内存模型，没法方法在执行的时候都会创建一个栈帧，用于储存局部变量表，
操作数栈，动态链，方法出口等信息，每个方法聪调用直至执行完成的过程，就对应着一个栈帧在虚拟机中
从入栈到出栈的过程。
栈帧，是用来储存数据和部分过程结果的数据结构，同时也用来处理动态链接

*** 本地方法栈

本地方法栈和虚拟机栈类似，是执行Native 方法的，如果一个 VM 实现 使用C-linkage模型来支持 Native 调用。

*** 程序计数器

一小块内存空间，当前线程所执行的字节码行号指示器，每条线程都有独立的程序计数器，线程私有的
正在执行java 方法的话，计数器记录的是虚拟机字节码指令的地址，如果还是 native 方法 则为空
这个内存区域，唯一一个在虚拟机中没有 任何 outofmemoryerror 的区域
*** 堆 

堆是运行时数据库，是线程共享的一块内存区域，创建对象和数组都保存在java 堆内存中，也是垃圾收集器进行垃圾回收最重要的内存区域。
现在采用分代收集算法，因此 java 堆从 GC 的角度可以分为 新生代（eden区，from survior区 和 to survior 区）和 老年代

** 运行时内存

*** 新生代

Java 堆从GC 的角度可以分为 新生代（Eden区 fromSurivior区 和 tosurvivorr 区） 和老年代，

新生代用来存放新生的对象。一半占据 1/3的空间。由于频繁创建对象，所以新生代会频繁触发 GC 进行垃圾回收，新生代又分为 Eden区，
ServivorFrom ServivorTo 三个区

Eden区 java 对象的出生地，占用大的内存直接进入老年代
ServivorFrom 上次GC的幸存者，作为这一次 GC 对的扫描者 
ServivorTO 保留一次 的幸存者

*** minorGC 的过程

eden,servicorFrom 复制到 servivorTo 年龄+1

清空 eden，servivorFrom 中的对象

最后 servicorTo 和 servivorfrom 互换。

*** 老年代

主要存放应用程序中生命周期长的内存对象。
老年代的对象比较稳定，所以majorGC 不会频繁执行。在进行 majorGC 采用的是 标记清除算法。

*** 永久代

主要存放 class 和 meta 元数据的信息， class 在被加载的时候被放入永久区域，它和存放实例的区域不同，GC 不会堆运行时期的永久代进行清理。所以
导致了永久代的区域会随着加载class 的增多而膨胀 最终 OOM


