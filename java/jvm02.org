* 垃圾回收算法

** gc 要做的三件事 
（1）哪些内存需要回收
（2）什么时候会回收
（3）怎么回收
** 哪些对象已经死亡  

1.引用计数法 
   循环引用问题
   在 Java 中对象是有关联的，要操作对象必须引用进行，通过引用记数法来判断一个对象是否可以回收，一个对象如果没有任何与之关联的引用，即他们的引用记数都不为0
则说明对象不太可能被用到，那么这个对象就是可回收对象。



2.根搜索算法
   GC Root Tracing  通过 CGRoots 的点作为七点，然后向下搜索，如果一个对象到 GCRoot 之间没有任何引用链相连，说明已死亡
   GC Root 主要又三个 VM 栈中的引用/方法区中的静态引用/JNI 中的引用

为解决引用记数循环引用问题，java 使用 可达性分析法，通过 GC root 作为对象的起点搜索。如果在GCRoot 和对象之间没有一个可到达路径，称该对象是不可达的
不可达对象不等价余可回收对象，不可达对象变为可回收对象至少要经过两次标记的过程。两次标记后仍然是可回收对象，将面临回收。

*** 垃圾收集算法

1.标记清除法
效率低，内存碎片多,清除之后会产生大量内存碎片

2.复制算法 
eden 区，fromservior区  toservior区
将内存分成两块。每次只使用其中一块，当这一块内存满后将商存活的对象复制到另一块上去，把已使用的内存清掉。
内存效率高，缺点占用内存，内存只使用原来的一半


3.标记整理法
标记后不清理对象，而是将对象移向内存的一端，然后清除边界意外的对象。


4.分代收集算法
（1） 新生代与复制算法
   JVM GC 对于新生代都采用 复制算法， 因为新生代中每次垃圾回收都需要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1 来划分新生代。一般将新生代划分为
一块较大的 eden空间和两个较小的 survivor 空间，每次使用 eden 空间和其中的一块survivor 空间，当进行回收时，将两块空间还存活的对象复制到另一块 survivor 空间中。

 (2) 老年代与标记复制法
   老年代每次只要回收少量对象，因此采用 标记复制算法
   1. java 虚拟机提到过的处于方法去的永生代，它用来储存 class 类，常量，方法描述等。 对于永生代的回收主要包括废弃的常量和无用的类。
   2. 对象的内存分配主要在新生代 edenspace 和 survior spac 少数情况会直接分配到老年代。
   3. 当新生代 eden Space 和 from space 空间不足时就会发生一次 GC 进行 GC 后，EdenSpace 和 fromSpace 区的存活对象会被挪到 toSpace ，然后将 edenspace 和from space 进行清理
   4. 如果tospace 无法储存某个对象，这个对象将直接存储到老年代中。
   5. 当对象在 survivor 区躲过一次 GC 后年龄就会 +1 默认年龄到达 15岁就会被移动到 老年代中。

5. 分区收集算法
分区算法将整个堆空间分为连续不同的小区间，每个小区间独立使用，独立回收，这样做的好处 是可以控制一次回收多少个小区间，根据目标的停顿时间，欸此合理的回收若干个小区间，而不是整个堆，从而不是整个堆。
减少 GC 所产生停顿。

*** 垃圾收集器

1. serial （单线程 复制算法）
serial 是最基本的垃圾收集器，使用复制算法，serial 是单线程收集器，它不但只会使用一个 cpu 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有工作线程，但是他简单高效
serial 垃圾收集器依然是 java 虚拟机在运行client 模式下的垃圾收集器

2.parNew（serial + 多线程）

parNew 垃圾收集器其实是 serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余行为和serial 收集器完全一样，parNew 垃圾收集器在垃圾收集过程中也同样要暂停所有其他
工作线程，默认开启线程数和 cpu 数目相同的线程数，可以通过 -XX：ParallelGCThreads 参数来限制垃圾收集器的额线程数
java 虚拟机在运行 Server 模式下新生代默认的垃圾收集器。

3. parallel scavenge (多线程，复制算法)
新生代收集器，也是采用复制算法，他重点关注的是程序到达一个可控制的吞吐量，自适应调节策略也是 parallelScavenge 收集器与 parnew 收集器的一个区别

4. serialOld（单线程标记整理）

是serial 收集器老年代版本，单线程收集 使用的是，标记-整理法，运行在 client 默认java 虚拟机默认的老年代垃圾收集器。
在server 模式下主要有两个用途：

1. 在 JDK 1.5 之前与新生代 parallelScavenge 收集器搭配使用
2. 作为老年代中使用 CMS 收集器的后备垃圾回收方案。

新生代 parallel Scavenge 收集器与 parNew 收集器工作原理类似，都是多线程的收集器，都使用复制算法，垃圾收集过程中需要暂停所有的工作线程

5 ParallelOld（多线程 标记整理法）
jdk 1.6 开始提供正是为了在老年代同样提供吞吐量优先的垃圾收集器



6 CMS（多线程标记清除法）

主要目的，获取最短的垃圾回收停顿时间，和其他老年代不一样使用多线程-标记清除算法

7 G1

G1 收集器避免全区域收集，他把堆的内存划分为大小固定的几个独立区域， 优先回收垃圾最多的区域


*** 参数

1. Xms
2. Xmx
3. Xmn

4. -XX：+PrintGCDetails
5. -XX：+SurvivorTatio
6. -XX: + PretenureSizeThreshold


*** Java 四种引用类型

1. 强引用

把一个对象赋值给一个引用变量，这个引用变量就是一个强引用，当一个对象被强引用变量引用时，时不能被垃圾回收机制回收的。强引用是造成内存泄露的主要原因。

2. 软引用
软引用需要用 sofrReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。

3.弱引用
弱引用需要用 WeakReference 类来实现，他比软引用的生存周期更短，对于弱引用的对象来说，只要垃圾回收一运行，不管JVM 空间是否足够都会回收该对象占用的空间

4.虚引用
虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。


